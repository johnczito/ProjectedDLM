# ==============================================================================
# Gibbs sampler for this model:
#
# y(t) = s(t) + e(t),       e(t) ~ N(0, v)
# s(t) = g s(t - 1) + h(t), h(t) ~ N(0, w)
# s(0) ~ N(s0, P0)
#    v ~ IG(a0, b0)
# g, w ~ NIG(...)
# ==============================================================================

gibbs_dlm <- function(y, v0, g0, w0, s0_prior, v_prior, gw_prior, check_expl, ndraw, burn, thin){
  # ----------------------------------------------------------------------------
  # dimensions
  # ----------------------------------------------------------------------------
  
  TT = length(y)
  M = burn + thin * ndraw
  
  # ----------------------------------------------------------------------------
  # unpack prior
  # ----------------------------------------------------------------------------
  
  s0 = s0_prior$s0
  P0 = s0_prior$P0
  
  # ----------------------------------------------------------------------------
  # preallocate storage
  # ----------------------------------------------------------------------------
  
  S_draws = matrix(0, TT, ndraw)
  v_draws = numeric(ndraw)
  g_draws = numeric(ndraw)
  w_draws = numeric(ndraw)
  
  # ----------------------------------------------------------------------------
  # initialize
  # ----------------------------------------------------------------------------
  
  v = v0
  g = g0
  w = w0
  draw = 0
  
  # ----------------------------------------------------------------------------
  # Run it hot!
  # ----------------------------------------------------------------------------
  
  for (m in 1:M) {
    
    #---------------------------------------------------------------------------
    # draw those states!
    #---------------------------------------------------------------------------
    
    s1 = g * s0
    P1 = g^2 * P0 + w
    
    model = SSModel(matrix(y) ~ -1 + SSMcustom(Z = diag(1),
                                               T = g * diag(1),
                                               R = diag(1),
                                               Q = w * diag(1),
                                               a1 = s1,
                                               P1 = P1,
                                               P1inf = matrix(0, 1, 1)),
                    H = v * diag(1))
    S = simulateSSM(model, type = "states", nsim = 1)[ , , 1]
    
    #---------------------------------------------------------------------------
    # draw the measurement variance
    #---------------------------------------------------------------------------
    
    v = sample_conjugate_posterior_invgamma(1, y - S, v_prior)
    
    #---------------------------------------------------------------------------
    # draw the state transition parameters
    #---------------------------------------------------------------------------
    
    gw = sample_conjugate_posterior_arp(S, 1, FALSE, gw_prior, check_expl)
    g = gw$b
    w = gw$sigsq
    
    #---------------------------------------------------------------------------
    #  store draw
    #---------------------------------------------------------------------------
    
    if ( retain_draw(m, burn, thin) ) {
      draw = draw + 1
      S_draws[, draw] = S
      v_draws[draw] = v
      g_draws[draw] = g
      w_draws[draw] = w
    }
  }
  
  draws = list(S = S_draws, v = v_draws, g = g_draws, w = w_draws)
  
  return(draws)
  
}